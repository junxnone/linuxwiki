---
Title | 并行计算优化 内存访问
-- | --
Create Date | `2021-11-15T08:35:48Z`
Update Date | `2021-11-15T17:34:33Z`
Edit link | [here](https://github.com/junxnone/linuxwiki/issues/216)

---
## Reference

- [Introduction to Parallel Computing Tutorial](https://hpc.llnl.gov/training/tutorials/introduction-parallel-computing-tutorial)
- [Putting Your Data and Code in Order: Optimization and Memory – Part 1](https://www.intel.com/content/www/us/en/developer/articles/technical/putting-your-data-and-code-in-order-optimization-and-memory-part-1.html)
- [Putting Your Data and Code in Order: Data and layout - Part 2](https://www.intel.com/content/www/us/en/developer/articles/training/putting-your-data-and-code-in-order-data-and-layout-part-2.html)


## Brief
- 两个基本原则
  - 最小化数据移动
  - 数据存储在离使用更近的地方

## Memory Arch
- **按访问速度排序:** Registers/L1/L2/L3/DRAM(Local Memory)/`Remote Memory`/`Swap space virtual memory`(Hard Disk/SSD)


![image](https://user-images.githubusercontent.com/2216970/141748602-3281ed57-a8ba-4fa6-9b75-9f29a307cb81.png)


## Data Use and Reuse

### Loop Ordering

- **i/j/k ordering**
- Loop k 中将多个值融入一个值(reduction operation)不能有效利用 SIMD 的并行
- 点积方法

```
for (i=0;i<n; i++) 
   for (j = 0; j<n; j++) 
     for (k=0;k<n; k++) 
         A[i][j] += B[i][k]* C[k][j] ;  
```

![image](https://user-images.githubusercontent.com/2216970/141824321-c26b058c-1dd1-41f4-9933-8d9111667898.png)

- **i/k/j ordering**
- 改成如下循环顺序可以有效利用 SIMD 和寄存器
- saxpy/daxpy
- icx 在某些优化模式下会自动交换循环顺序

```
for (i=0;i<n; i++)
   for (k = 0; k<n; k++)
     for (j=0;j<n; j++)
       a[i][j] += b[i][k]* c[k][j] ;
```

![image](https://user-images.githubusercontent.com/2216970/141824461-394bfd15-1839-454e-aebe-ca11b3fec18b.png)

### Data Reuse

- 上述例子中, 当 n 比较大时, 中间循环读取到的 vectors 只能被使用一次
- submatrices/blocksize

```
for (i = 0; i < n; i+=blockSize)
   for (k=0; k<n ; k+= blockSize)   
      for (j = 0 ; j < n; j+=blockSize)      
         for (iInner = i; iInner<j+blockSize; iInner++)     
            for (kInner = k ; kInner<k+blockSize; kInner++)
               for (jInner = j ; jInner<j+blockSize ; jInner++)
                 a[iInner,jInner] += b[iInner,kInner] *
                    c[kInner, jInner]
```

![image](https://user-images.githubusercontent.com/2216970/141827719-06279fff-e0e3-4fa6-a68c-bc9557b7f6c4.png)


